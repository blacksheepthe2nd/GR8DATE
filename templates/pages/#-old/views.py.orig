# pages/views.py
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.db.models import Q
from django.utils import timezone
from .models import Profile, ProfileImage, Blog, Like, Thread, Message, Block
from django.contrib.auth import get_user_model
from django.http import JsonResponse
User = get_user_model()

# ---------------------------------------------------------------------
# Core Pages
# ---------------------------------------------------------------------

def home(request):
    """Home page"""
    return render(request, 'pages/home.html')

@login_required
def dashboard(request):
    """User dashboard"""
    try:
        profile = request.user.profile
    except Profile.DoesNotExist:
        profile = Profile.objects.create(user=request.user)
    
    # Only show approved profiles in search/dashboard
    approved_profiles = Profile.objects.filter(
        is_approved=True
    ).exclude(user=request.user)
    
    # Safe counts to avoid errors
    likes_received_count = Like.objects.filter(liked_user=request.user).count()
    likes_given_count = Like.objects.filter(liker=request.user).count()
    threads_count = Thread.objects.filter(
        Q(user_a=request.user) | Q(user_b=request.user)
    ).count()
    
    context = {
        'profile': profile,
        'approved_profiles_count': approved_profiles.count(),
        'likes_received_count': likes_received_count,
        'likes_given_count': likes_given_count,
        'threads_count': threads_count,
    }
    return render(request, 'pages/gr8date_dashboard_fixed_v10_nolines.html', context)

# ---------------------------------------------------------------------
# Profile Management
# ---------------------------------------------------------------------

@login_required
def profile_view(request):
    """View own profile"""
    profile, created = Profile.objects.get_or_create(user=request.user)
    context = {
        'profile': profile,
        'is_own_profile': True,
    }
    return render(request, 'pages/profile_view.html', context)

@login_required
def profile_edit(request):
    """Edit own profile - requires admin approval for changes"""
    profile, created = Profile.objects.get_or_create(user=request.user)
    
    # Get existing images
    existing_public_images = ProfileImage.objects.filter(profile=profile, is_private=False)
    existing_private_images = ProfileImage.objects.filter(profile=profile, is_private=True)
        
    if request.method == 'POST':
        # Store changes in pending_changes instead of saving directly
        pending_data = {
            'headline': request.POST.get('headline', ''),
            'about': request.POST.get('about', ''),
            'location': request.POST.get('location', ''),
            'children': request.POST.get('children', ''),
            'my_interests': request.POST.get('my_interests', ''),
            'must_have_tags': request.POST.get('must_have_tags', ''),
            'preferred_age_min': request.POST.get('preferred_age_min', 18),
            'preferred_age_max': request.POST.get('preferred_age_max', 60),
            'preferred_distance': request.POST.get('preferred_distance', ''),
            'preferred_intent': request.POST.get('preferred_intent', ''),
            'smoking': request.POST.get('smoking', ''),
            'drinking': request.POST.get('drinking', ''),
            'exercise': request.POST.get('exercise', ''),
            'pets': request.POST.get('pets', ''),
            'diet': request.POST.get('diet', ''),
            'submitted_at': timezone.now().isoformat(),
        }
        
        # Convert age preferences to integers
        try:
            pending_data['preferred_age_min'] = int(pending_data['preferred_age_min'])
            pending_data['preferred_age_max'] = int(pending_data['preferred_age_max'])
        except (ValueError, TypeError):
            pending_data['preferred_age_min'] = profile.preferred_age_min
            pending_data['preferred_age_max'] = profile.preferred_age_max
        
        # Save to pending_changes and mark for review
        profile.pending_changes = pending_data
        profile.needs_review = True
        profile.last_submitted_for_approval = timezone.now()
        profile.save()
        
        messages.success(request, "Your profile changes have been submitted for admin approval! Your current profile remains active until approved. If there are any questions, admin will be in contact.")
        return redirect('profile_view')
        
    # For GET requests, show current data (not pending changes)
    context = {
        'profile': profile,
        'existing_public_images': existing_public_images,
        'existing_private_images': existing_private_images,
        'has_pending_changes': profile.needs_review,
    }
    return render(request, 'pages/profile_edit.html', context)

@login_required
def profile_detail(request, user_id):
    """View another user's profile"""
    user = get_object_or_404(User, id=user_id)
    profile = get_object_or_404(Profile, user=user, is_approved=True)
    
    context = {
        'profile': profile,
        'is_own_profile': False,
    }
    return render(request, 'pages/profile_view.html', context)

# ---------------------------------------------------------------------
# Search & Discovery
# ---------------------------------------------------------------------

@login_required
def search(request):
    """Search for profiles"""
    try:
        my_profile = request.user.profile
    except Profile.DoesNotExist:
        my_profile = Profile.objects.create(user=request.user)
    
    profiles = Profile.objects.all().exclude(user=request.user)
    
    # Basic filters (you can expand these)
    gender_filter = request.GET.get('gender')
    if gender_filter:
        profiles = profiles.filter(my_gender=gender_filter)
    
    age_min = request.GET.get('age_min')
    if age_min:
        try:
            profiles = profiles.filter(age__gte=int(age_min))
        except (ValueError, TypeError):
            pass
    
    age_max = request.GET.get('age_max')
    if age_max:
        try:
            profiles = profiles.filter(age__lte=int(age_max))
        except (ValueError, TypeError):
            pass
    
    context = {
        'profiles': profiles,
        'my_profile': my_profile,
    }
    return render(request, 'pages/search.html', context)

# ---------------------------------------------------------------------
# Likes & Matching
# ---------------------------------------------------------------------

@login_required
def like_user(request, user_id):
    """Like another user"""
    if request.method == 'POST':
        target_user = get_object_or_404(User, id=user_id)
        
        # Check if already liked
        existing_like = Like.objects.filter(
            liker=request.user, 
            liked_user=target_user
        ).first()
        
        if not existing_like:
            Like.objects.create(liker=request.user, liked_user=target_user)
            messages.success(request, f"You liked {target_user.username}!")
        else:
            messages.info(request, f"You already liked {target_user.username}!")
    
    return redirect('search')

@login_required
def likes_received(request):
    """View likes received"""
    likes = Like.objects.filter(liked_user=request.user).select_related('liker__profile')
    
    context = {
        'likes': likes,
    }
    return render(request, 'pages/likes_received.html', context)

# ---------------------------------------------------------------------
# Messaging
# ---------------------------------------------------------------------

@login_required
def messages_list(request):
    """List of message threads"""
    threads = Thread.for_user(request.user).prefetch_related('messages')
    
    context = {
        'threads': threads,
    }
    return render(request, 'pages/messages_list.html', context)

@login_required
def message_thread(request, user_id):
    """Individual message thread with another user"""
    other_user = get_object_or_404(User, id=user_id)
    thread = Thread.get_or_create_for(request.user, other_user)
    
    # Get messages visible to current user
    messages = [
        msg for msg in thread.messages.all() 
        if msg.is_visible_to_user(request.user)
    ]
    
    if request.method == 'POST':
        text = request.POST.get('text', '').strip()
        if text and not is_blocked(request.user, other_user):
            Message.objects.create(
                thread=thread,
                sender=request.user,
                recipient=other_user,
                text=text
            )
            return redirect('message_thread', user_id=user_id)
    
    context = {
        'thread': thread,
        'other_user': other_user,
        'messages': messages,
    }
    return render(request, 'pages/message_thread.html', context)

# ---------------------------------------------------------------------
# Blog
# ---------------------------------------------------------------------

def blog_list(request):
    """List all published blog posts"""
    posts = Blog.objects.filter(
        status=Blog.Status.PUBLISHED,
        published_at__lte=timezone.now()
    )
    
    context = {
        'posts': posts,
    }
    return render(request, 'pages/blog_list.html', context)

def blog_detail(request, slug):
    """Individual blog post"""
    post = get_object_or_404(Blog, slug=slug, status=Blog.Status.PUBLISHED)
    
    context = {
        'post': post,
    }
    return render(request, 'pages/blog_detail.html', context)

# ---------------------------------------------------------------------
# Admin Approval System
# ---------------------------------------------------------------------

@login_required
def admin_profile_approvals(request):
    """Admin view to see profiles needing approval"""
    if not request.user.is_superuser:
        messages.error(request, "Access denied.")
        return redirect('dashboard')
    
    profiles_needing_approval = Profile.objects.filter(needs_review=True).select_related('user')
    
    context = {
        'profiles': profiles_needing_approval,
    }
    return render(request, 'pages/admin_profile_approvals.html', context)

@login_required
def admin_approve_profile(request, profile_id):
    """Approve profile changes"""
    if not request.user.is_superuser:
        messages.error(request, "Access denied.")
        return redirect('dashboard')
    
    profile = get_object_or_404(Profile, id=profile_id)
    
    if profile.pending_changes:
        # Apply all pending changes
        for field, value in profile.pending_changes.items():
            if field != 'submitted_at' and hasattr(profile, field):
                setattr(profile, field, value)
        
        # Clear pending changes and mark as approved
        profile.pending_changes = None
        profile.needs_review = False
        profile.is_approved = True
        profile.save()
        
        messages.success(request, f"Profile changes for {profile.user.username} approved!")
    else:
        messages.error(request, "No pending changes found.")
    
    return redirect('admin_profile_approvals')

@login_required
def admin_reject_profile(request, profile_id):
    """Reject profile changes"""
    if not request.user.is_superuser:
        messages.error(request, "Access denied.")
        return redirect('dashboard')
    
    profile = get_object_or_404(Profile, id=profile_id)
    
    # Clear pending changes without applying them
    profile.pending_changes = None
    profile.needs_review = False
    profile.save()
    
    messages.info(request, f"Profile changes for {profile.user.username} rejected.")
    return redirect('admin_profile_approvals')

# ---------------------------------------------------------------------
# Blocking
# ---------------------------------------------------------------------

@login_required
def block_user(request, user_id):
    """Block another user"""
    if request.method == 'POST':
        user_to_block = get_object_or_404(User, id=user_id)
        
        # Check if already blocked
        existing_block = Block.objects.filter(
            blocker=request.user,
            blocked=user_to_block
        ).first()
        
        if not existing_block:
            Block.objects.create(blocker=request.user, blocked=user_to_block)
            messages.success(request, f"You blocked {user_to_block.username}.")
        else:
            messages.info(request, f"You already blocked {user_to_block.username}.")
    
    return redirect('search')

# ---------------------------------------------------------------------
# Helper Functions
# ---------------------------------------------------------------------

def is_blocked(a, b):
    """Check if there's a block between two users"""
    return Block.objects.filter(
        Q(blocker=a, blocked=b) | Q(blocker=b, blocked=a)
    ).exists()

@login_required
def messages_unread_count(request):
    """Return unread message count for AJAX requests"""
    count = 0
    return JsonResponse({'count': count, 'preview': False})
